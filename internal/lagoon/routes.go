package lagoon

import (
	"encoding/json"
	"reflect"
	"strconv"

	"github.com/uselagoon/build-deploy-tool/internal/helpers"
)

// RoutesV2 is the new routes definition
type RoutesV2 struct {
	Routes []RouteV2 `json:"routes"`
}

// RouteV2 is the new route definition
type RouteV2 struct {
	Domain                string            `json:"domain"`
	LagoonService         string            `json:"service"`
	ComposeService        string            `json:"composeService"` // the
	TLSAcme               *bool             `json:"tls-acme"`
	Migrate               *bool             `json:"migrate,omitempty"`
	Insecure              *string           `json:"insecure,omitempty"`
	MonitoringPath        string            `json:"monitoring-path,omitempty"`
	Fastly                Fastly            `json:"fastly,omitempty"`
	Annotations           map[string]string `json:"annotations"`
	Labels                map[string]string `json:"labels"`
	AlternativeNames      []string          `json:"alternativeNames"`
	ServicePortNumber     *int32            `json:"servicePortNumber"`
	ServicePortName       *string           `json:"servicePortName"`
	IngressName           string            `json:"ingressName"`
	IngressClass          string            `json:"ingressClass"`
	HSTSEnabled           *bool             `json:"hstsEnabled,omitempty"`
	HSTSMaxAge            int               `json:"hstsMaxAge,omitempty"`
	HSTSIncludeSubdomains *bool             `json:"hstsIncludeSubdomains,omitempty"`
	HSTSPreload           *bool             `json:"hstsPreload,omitempty"`
	Autogenerated         bool              `json:"-"`
}

// Ingress represents a Lagoon route.
type Ingress struct {
	TLSAcme               *bool             `json:"tls-acme,omitempty"`
	Migrate               *bool             `json:"migrate,omitempty"`
	Insecure              *string           `json:"insecure,omitempty"`
	MonitoringPath        string            `json:"monitoring-path,omitempty"`
	Fastly                Fastly            `json:"fastly,omitempty"`
	Annotations           map[string]string `json:"annotations,omitempty"`
	IngressClass          string            `json:"ingressClass"`
	HSTSEnabled           *bool             `json:"hstsEnabled,omitempty"`
	HSTSMaxAge            int               `json:"hstsMaxAge,omitempty"`
	HSTSIncludeSubdomains *bool             `json:"hstsIncludeSubdomains,omitempty"`
	HSTSPreload           *bool             `json:"hstsPreload,omitempty"`
}

// Route can be either a string or a map[string]Ingress, so we must
// implement a custom unmarshaller.
type Route struct {
	Name      string
	Ingresses map[string]Ingress
}

var defaultHSTSMaxAge = 31536000

// UnmarshalJSON implements json.Unmarshaler.
func (r *Route) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &r.Name); err == nil {
		return nil
	}
	if err := json.Unmarshal(data, &r.Ingresses); err != nil {
		// @TODO: eventually lagoon should be more strict, but in lagoonyaml version 2 we could do this
		// some things in .lagoon.yml can be defined as a bool or string and lagoon builds don't care
		// but types are more strict, so this unmarshaler attempts to change between the two types
		// that can be bool or string
		tmpMap := map[string]interface{}{}
		json.Unmarshal(data, &tmpMap)
		for k := range tmpMap {
			if _, ok := tmpMap[k].(map[string]interface{})["tls-acme"]; ok {
				if reflect.TypeOf(tmpMap[k].(map[string]interface{})["tls-acme"]).Kind() == reflect.String {
					vBool, err := strconv.ParseBool(tmpMap[k].(map[string]interface{})["tls-acme"].(string))
					if err == nil {
						tmpMap[k].(map[string]interface{})["tls-acme"] = vBool
					}
				}
			}
			if _, ok := tmpMap[k].(map[string]interface{})["fastly"]; ok {
				if reflect.TypeOf(tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"]).Kind() == reflect.String {
					vBool, err := strconv.ParseBool(tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"].(string))
					if err == nil {
						tmpMap[k].(map[string]interface{})["fastly"].(map[string]interface{})["watch"] = vBool
					}
				}
			}
		}
		newData, _ := json.Marshal(tmpMap)
		return json.Unmarshal(newData, &r.Ingresses)
	}
	return json.Unmarshal(data, &r.Ingresses)
}

// GenerateRoutesV2 generate routesv2 definitions from lagoon route mappings
func GenerateRoutesV2(genRoutes *RoutesV2, routeMap map[string][]Route, variables []EnvironmentVariable, defaultIngressClass, secretPrefix string, activeStandby bool) {
	for rName, lagoonRoutes := range routeMap {
		for _, lagoonRoute := range lagoonRoutes {
			newRoute := RouteV2{}
			// set the defaults for routes
			newRoute.TLSAcme = helpers.BoolPtr(true)
			newRoute.Insecure = helpers.StrPtr("Redirect")
			newRoute.MonitoringPath = "/"
			newRoute.Annotations = map[string]string{}
			newRoute.Fastly.ServiceID = ""
			newRoute.Fastly.Watch = false
			newRoute.IngressClass = defaultIngressClass
			if activeStandby {
				newRoute.Migrate = helpers.BoolPtr(true)
			}
			if lagoonRoute.Name == "" {
				// this route from the lagoon route map contains field overrides
				// update them from the defaults in this case
				for iName, ingress := range lagoonRoute.Ingresses {
					newRoute.Domain = iName
					newRoute.LagoonService = rName
					newRoute.IngressClass = defaultIngressClass
					newRoute.Fastly = ingress.Fastly
					if ingress.Annotations != nil {
						newRoute.Annotations = ingress.Annotations
					}
					if ingress.TLSAcme != nil {
						newRoute.TLSAcme = ingress.TLSAcme
					}
					if ingress.Insecure != nil {
						newRoute.Insecure = ingress.Insecure
					}
					if ingress.IngressClass != "" {
						newRoute.IngressClass = ingress.IngressClass
					}
					if ingress.MonitoringPath != "" {
						newRoute.MonitoringPath = ingress.MonitoringPath
					}

					// handle hsts here
					if ingress.HSTSEnabled != nil {
						newRoute.HSTSEnabled = ingress.HSTSEnabled
					}
					if ingress.HSTSIncludeSubdomains != nil {
						newRoute.HSTSIncludeSubdomains = ingress.HSTSIncludeSubdomains
					}
					if ingress.HSTSPreload != nil {
						newRoute.HSTSPreload = ingress.HSTSPreload
					}
					if ingress.HSTSMaxAge > 0 {
						newRoute.HSTSMaxAge = ingress.HSTSMaxAge
					} else {
						if newRoute.HSTSEnabled != nil && *newRoute.HSTSEnabled {
							newRoute.HSTSMaxAge = defaultHSTSMaxAge // set default hsts value if one not provided
						}
					}
					// hsts end
				}
			} else {
				// this route is just a domain
				// keep the defaults, just set the name and service
				newRoute.Domain = lagoonRoute.Name
				newRoute.LagoonService = rName
			}
			// generate the fastly configuration for this route
			err := GenerateFastlyConfiguration(&newRoute.Fastly, "", newRoute.Fastly.ServiceID, newRoute.Domain, secretPrefix, variables)
			if err != nil {
				//@TODO: error handling
			}

			genRoutes.Routes = append(genRoutes.Routes, newRoute)
		}
	}
}

// MergeRoutesV2 merge routes from the API onto the previously generated routes.
func MergeRoutesV2(genRoutes RoutesV2, apiRoutes RoutesV2, variables []EnvironmentVariable, defaultIngressClass, secretPrefix string) RoutesV2 {
	finalRoutes := RoutesV2{}
	existsInAPI := false
	// replace any routes from the lagoon yaml with ones from the api
	// this only modifies ones that exist in lagoon yaml
	for _, route := range genRoutes.Routes {
		add := RouteV2{}
		for _, aRoute := range apiRoutes.Routes {
			if aRoute.Domain == route.Domain {
				existsInAPI = true
				add = aRoute
				add.Fastly = aRoute.Fastly
				if aRoute.TLSAcme != nil {
					add.TLSAcme = aRoute.TLSAcme
				} else {
					add.TLSAcme = helpers.BoolPtr(true)
				}
				if aRoute.Insecure != nil {
					add.Insecure = aRoute.Insecure
				} else {
					add.Insecure = helpers.StrPtr("Redirect")
				}
				if aRoute.Annotations != nil {
					add.Annotations = aRoute.Annotations
				} else {
					add.Annotations = map[string]string{}
				}
				if aRoute.IngressClass != "" {
					add.IngressClass = aRoute.IngressClass
				} else {
					add.IngressClass = defaultIngressClass
				}

				// handle hsts here
				if aRoute.HSTSEnabled != nil {
					add.HSTSEnabled = aRoute.HSTSEnabled
				}
				if aRoute.HSTSIncludeSubdomains != nil {
					add.HSTSIncludeSubdomains = aRoute.HSTSIncludeSubdomains
				}
				if aRoute.HSTSPreload != nil {
					add.HSTSPreload = aRoute.HSTSPreload
				}
				if aRoute.HSTSMaxAge > 0 {
					add.HSTSMaxAge = aRoute.HSTSMaxAge
				} else {
					if add.HSTSEnabled != nil && *add.HSTSEnabled {
						add.HSTSMaxAge = defaultHSTSMaxAge // set default hsts value if one not provided
					}
				}
				// hsts end
			}
		}
		if existsInAPI {
			finalRoutes.Routes = append(finalRoutes.Routes, add)
			existsInAPI = false
		} else {
			finalRoutes.Routes = append(finalRoutes.Routes, route)
		}
	}
	// add any that exist in the api only to the final routes list
	for _, aRoute := range apiRoutes.Routes {
		add := aRoute
		add.Fastly = aRoute.Fastly
		if aRoute.TLSAcme != nil {
			add.TLSAcme = aRoute.TLSAcme
		} else {
			add.TLSAcme = helpers.BoolPtr(true)
		}
		if aRoute.Insecure != nil {
			add.Insecure = aRoute.Insecure
		} else {
			add.Insecure = helpers.StrPtr("Redirect")
		}
		if aRoute.Annotations != nil {
			add.Annotations = aRoute.Annotations
		} else {
			add.Annotations = map[string]string{}
		}
		if aRoute.IngressClass != "" {
			add.IngressClass = aRoute.IngressClass
		} else {
			add.IngressClass = defaultIngressClass
		}

		// handle hsts here
		if aRoute.HSTSEnabled != nil {
			add.HSTSEnabled = aRoute.HSTSEnabled
		}
		if aRoute.HSTSIncludeSubdomains != nil {
			add.HSTSIncludeSubdomains = aRoute.HSTSIncludeSubdomains
		}
		if aRoute.HSTSPreload != nil {
			add.HSTSPreload = aRoute.HSTSPreload
		}
		if aRoute.HSTSMaxAge > 0 {
			add.HSTSMaxAge = aRoute.HSTSMaxAge
		} else {
			if add.HSTSEnabled != nil && *add.HSTSEnabled {
				add.HSTSMaxAge = defaultHSTSMaxAge // set default hsts value if one not provided
			}
		}
		// hsts end

		for _, route := range finalRoutes.Routes {
			if aRoute.Domain == route.Domain {
				existsInAPI = true
			}
		}
		if existsInAPI {
			existsInAPI = false
		} else {
			finalRoutes.Routes = append(finalRoutes.Routes, add)
		}
	}
	finalRoutes2 := RoutesV2{}
	for _, fRoute := range finalRoutes.Routes {
		// generate the fastly configuration for this route if required
		err := GenerateFastlyConfiguration(&fRoute.Fastly, "", fRoute.Fastly.ServiceID, fRoute.Domain, secretPrefix, variables)
		if err != nil {
			//@TODO: error handling
		}
		finalRoutes2.Routes = append(finalRoutes2.Routes, fRoute)
	}
	return finalRoutes2
}
