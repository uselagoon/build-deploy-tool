package templating

import (
	"fmt"
	"os"
	"strings"

	"github.com/uselagoon/build-deploy-tool/internal/generator"
	"github.com/uselagoon/build-deploy-tool/internal/lagoon"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	networkv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
	"sigs.k8s.io/yaml"
)

func GenerateOauth2ProxyTemplate(routes *[]lagoon.RouteV2, bValues generator.BuildValues) (*metav1.List, error) {
	o2pServiceName := bValues.Namespace + "-oauth2proxy"
	o2pServicePort := int32(4180)
	keycloakURL := os.Getenv("LAGOON_FEATURE_FLAG_DEFAULT_KEYCLOAK_FRONTEND_URL") + "/auth/realms/lagoon"

	var o2pHosts []string
	var cookieDomains []string
	for i := range *routes {
		o2pHosts = append(o2pHosts, "o2p."+(*routes)[i].Domain)
		cookieDomains = append(cookieDomains, (*routes)[i].Domain)
		(*routes)[i].Oauth2ProxyDomain = "o2p." + (*routes)[i].Domain
	}



	ingressLabels := map[string]string{
		"app.kubernetes.io/name":       "oauth2proxy",
		"app.kubernetes.io/managed-by": "build-deploy-tool",
		"app.kubernetes.io/instance":   "bdt-controlled-oauth2proxy",
		"lagoon.sh/autogenerated":      "false",
		"lagoon.sh/template":           "bdt-controlled-oauth2proxy-0.1.0",
		"lagoon.sh/service":            o2pServiceName,
		"lagoon.sh/service-type":       "bdt-controlled-oauth2proxy",
		"lagoon.sh/project":            bValues.Project,
		"lagoon.sh/environment":        bValues.Environment,
		"lagoon.sh/environmentType":    bValues.EnvironmentType,
		"lagoon.sh/buildType":          bValues.BuildType,
        "lagoon.sh/remove":             "false",
	}

	var ingressRules []networkv1.IngressRule
	for _, host := range o2pHosts {
		rule := networkv1.IngressRule{
			Host: host,
			IngressRuleValue: networkv1.IngressRuleValue{
				HTTP: &networkv1.HTTPIngressRuleValue{
					Paths: []networkv1.HTTPIngressPath{
						{
							Path:     "/",
							PathType: func() *networkv1.PathType { pt := networkv1.PathTypePrefix; return &pt }(),
							Backend: networkv1.IngressBackend{
								Service: &networkv1.IngressServiceBackend{
									Name: o2pServiceName,
									Port: networkv1.ServiceBackendPort{
										Number: o2pServicePort,
									},
								},
							},
						},
					},
				},
			},
		}
		ingressRules = append(ingressRules, rule)
	}

	ingress := &networkv1.Ingress{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "networking.k8s.io/v1",
			Kind:       "Ingress",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:   o2pServiceName,
			Labels: ingressLabels,
			Annotations: map[string]string{
				"acme.cert-manager.io/http01-ingress-class":     "nginx",
				"kubernetes.io/tls-acme":                        "true",
				"nginx.ingress.kubernetes.io/proxy-buffer-size": "16k",
				"nginx.ingress.kubernetes.io/ssl-redirect":      "false",
			},
		},
		Spec: networkv1.IngressSpec{
			IngressClassName: func() *string { s := "nginx"; return &s }(),
			TLS: []networkv1.IngressTLS{
				{
					Hosts:      o2pHosts,
					SecretName: "oauth2proxy-tls",
				},
			},
			Rules: ingressRules,
		},
	}

	serviceLabels := map[string]string {
		"app.kubernetes.io/managed-by": "build-deploy-tool",
		"app.kubernetes.io/name": "oauth2proxy",
		"app.kubernetes.io/instance": "bdt-controlled-oauth2proxy",
		"lagoon.sh/project":            bValues.Project,
		"lagoon.sh/environment":        bValues.Environment,
		"lagoon.sh/environmentType":    bValues.EnvironmentType,
		"lagoon.sh/buildType":          bValues.BuildType,
	}

	service := &corev1.Service{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "Service",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: o2pServiceName,
			Labels: serviceLabels,
		},
		Spec: corev1.ServiceSpec{
			Selector: map[string]string{
				"app.kubernetes.io/name": "oauth2proxy",
				"app.kubernetes.io/instance": "bdt-controlled-oauth2proxy",
			},
			Ports: []corev1.ServicePort{
				{
					Name:       "http-o2p",
					Port:       o2pServicePort,
					TargetPort: intstr.FromInt32(o2pServicePort),
					Protocol:   corev1.ProtocolTCP,
				},
			},
			Type: corev1.ServiceTypeClusterIP,
		},
	}

	labels := map[string]string{
		"app.kubernetes.io/managed-by": "build-deploy-tool",
		"app.kubernetes.io/name":       "oauth2proxy",
		"app.kubernetes.io/instance":   "bdt-controlled-oauth2proxy",
		"lagoon.sh/project":            bValues.Project,
		"lagoon.sh/environment":        bValues.Environment,
		"lagoon.sh/environmentType":    bValues.EnvironmentType,
		"lagoon.sh/buildType":          bValues.BuildType,
		"lagoon.sh/template":           "bdt-controlled-oauth2proxy-0.1.0",
		"lagoon.sh/service":            "bdt-controlled-oauth2proxy",
		"lagoon.sh/service-type":       "oauth2proxy",
	}

	deployment := &appsv1.Deployment{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "apps/v1",
			Kind:       "Deployment",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: "oauth2proxy",
			Labels: labels,
		},
		Spec: appsv1.DeploymentSpec{
			Selector: &metav1.LabelSelector{
				MatchLabels: map[string]string{
					"app.kubernetes.io/name": "oauth2proxy",
					"app.kubernetes.io/instance": "bdt-controlled-oauth2proxy",
				},
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: labels,
				},
				Spec: corev1.PodSpec{
					Containers: []corev1.Container{
						{
							Name:  "oauth2proxy",
							Image: "registry.172.19.0.240.nip.io/library/oauth2-proxy:o2p-authentication",
							Ports: []corev1.ContainerPort{
								{
									ContainerPort: o2pServicePort,
									Name:          "http-o2p",
								},
							},
							ReadinessProbe: &corev1.Probe{
								ProbeHandler: corev1.ProbeHandler{
									HTTPGet: &corev1.HTTPGetAction{
										Path: "/ping",
										Port: intstr.FromString("http-o2p"),
									},
								},
								PeriodSeconds:  10,
								TimeoutSeconds: 1,
							},
							Env: []corev1.EnvVar{
								{Name: "OAUTH2_PROXY_LAGOON_ENDPOINT", Value: "http://lagoon-api.172.19.0.240.nip.io/graphql"},
								{Name: "OAUTH2_PROXY_INSECURE_OIDC_SKIP_ISSUER_VERIFICATION", Value: "true"},
								{Name: "OAUTH2_PROXY_INSECURE_OIDC_ALLOW_UNVERIFIED_EMAIL", Value: "true"},
								//{
								//	Name: "OAUTH2_PROXY_CLIENT_SECRET",
								//	ValueFrom: &corev1.EnvVarSource{
								//		SecretKeyRef: &corev1.SecretKeySelector{
								//			LocalObjectReference: corev1.LocalObjectReference{Name: "lagoon-core-keycloak"},
								//			Key:                  "KEYCLOAK_LAGOON_O2P_CLIENT_SECRET",
								//		},
								//	},
								//},
								//{
								//	Name: "OAUTH2_PROXY_COOKIE_SECRET",
								//	ValueFrom: &corev1.EnvVarSource{
								//		SecretKeyRef: &corev1.SecretKeySelector{
								//			LocalObjectReference: corev1.LocalObjectReference{Name: "lagoon-core-oauth2proxy"},
								//			Key:                  "OAUTH2_PROXY_COOKIE_SECRET",
								//		},
								//	},
								//},
								{Name: "OAUTH2_PROXY_CLIENT_SECRET", Value: "2c88d6cc-ba02-410b-b244-39a186011fb4"},
								{Name: "OAUTH2_PROXY_COOKIE_SECRET", Value: "ozKSRCpcWddKBnfjayfYuBMEvPlpgoEI"},
								{Name: "OAUTH2_PROXY_PROVIDER", Value: "oidc"},
								{Name: "OAUTH2_PROXY_CLIENT_ID", Value: "lagoon-oauth2proxy"},
								{Name: "OAUTH2_PROXY_HTTP_ADDRESS", Value: "0.0.0.0:4180"},
								{Name: "OAUTH2_PROXY_OIDC_ISSUER_URL", Value: keycloakURL},
								{Name: "OAUTH2_PROXY_EMAIL_DOMAINS", Value: "*"},
								{Name: "OAUTH2_PROXY_COOKIE_SECURE", Value: "false"},
								{Name: "OAUTH2_PROXY_COOKIE_DOMAINS", Value: strings.Join(cookieDomains, ",")},
								{Name: "OAUTH2_PROXY_COOKIE_CSRF_PER_REQUEST", Value: "true"},
								{Name: "OAUTH2_PROXY_WHITELIST_DOMAINS", Value: strings.Join(cookieDomains, ",")},
								{Name: "OAUTH2_PROXY_SCOPE", Value: "openid email profile"},
								{Name: "OAUTH2_PROXY_CODE_CHALLENGE_METHOD", Value: "S256"},
								{Name: "OAUTH2_PROXY_REVERSE_PROXY", Value: "false"},
								{Name: "OAUTH2_PROXY_PING_PATH", Value: "/ping"},
								{Name: "OAUTH2_PROXY_SILENCE_PING_LOGGING", Value: "true"},
							},
						},
					},
				},
			},
		},
	}

	templ := &metav1.List{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "List",
		},
		Items: []runtime.RawExtension{
			{Object: deployment},
			{Object: service},
			{Object: ingress},
		},
	}

	return templ, nil
}

func TemplateOauth2Proxy(o2p *metav1.List) ([]byte, error) {
	separator := []byte("---\n")
	var templateYAML []byte
	iBytes, err := yaml.Marshal(o2p)
	if err != nil {
		return nil, fmt.Errorf("couldn't generate template: %v", err)
	}
	restoreResult := append(separator[:], iBytes[:]...)
	templateYAML = append(templateYAML, restoreResult[:]...)
	return templateYAML, nil
}
